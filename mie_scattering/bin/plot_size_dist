#!/usr/bin/env python3

import sys
import os
import pst
import numpy as np
from matplotlib import pyplot as plt
from scipy import optimize

COL = [
	'#0084C8',
	'#DC0000',
	'#009100',
	'#FFC022',
]

def lognorm_reff(mu, sigma2):
	return np.exp(mu + 5./2.*sigma2)

def lognorm_sigma2eff(mu, sigma2):
	return (np.exp(4.*mu + 8.*sigma2) - np.exp(4.*mu + 7.*sigma2))/np.exp(2.*mu + 2.*sigma2)

def lognorm_find_mu_sigma2(reff, sigma2eff):
	def f(x):
		mu = x[0]
		sigma2 = x[1]
		return [
			lognorm_reff(mu, sigma2) - reff,
			lognorm_sigma2eff(mu, sigma2) - sigma2eff
		]
	res = optimize.root(f, [np.log(reff), np.log(sigma2eff)])
	mu, sigma2 = res.x
	return mu, sigma2

def lognorm_pdf(r, mu, sigma):
	return 1./r*np.exp(-((np.log(r) - mu)**2.)/(2.*sigma**2.))

def gamma_pdf(r, reff, sigmaeff):
	nueff = (sigmaeff/reff)**2.
	return r**((1. - 3.*nueff)/nueff)*np.exp(-r/(reff*nueff))

def reff_num(r, n):
	return np.sum(r**3.*n)/np.sum(r**2.*n)

def sigma2eff_num(r, n, reff):
	return np.sum((r - reff)**2.*r**2.*n)/np.sum(r**2.*n)

def calc_sd(r, n):
	mean = calc_mean(r, n)
	return np.sqrt(np.sum((r - mean)**2.*n)/np.sum(n))

def calc_mean(r, n):
	return np.sum(r*n)/np.sum(n)

def plot(type_, reff, sigmaeff, col):
	sigma2eff = sigmaeff**2.

	if type_ == b'lognorm':
		#title = 'Particle size distribution (log-normal), r$_\\mathrm{eff}$ = %d $\mu$m' % mean
		label = 'lognorm r$_\\mathrm{eff}$ = %.0f $\\mu$m, $\\sigma_\\mathrm{eff}$ = %.0f $\\mu$m' % (reff, sigmaeff)
		mu, sigma2 = lognorm_find_mu_sigma2(reff, sigma2eff)
		n = lognorm_pdf(r, mu, np.sqrt(sigma2))
		print('reff: %f sigmaeff: %f mu: %f sigma: %f reff_sol: %f sigmaeff_sol: %f reff_num: %f sigmaeff_num: %f mean: %f sd: %f' % (
			reff,
			sigmaeff,
			mu,
			np.sqrt(sigma2),
			lognorm_reff(mu, sigma2),
			np.sqrt(lognorm_sigma2eff(mu, sigma2)),
			reff_num(r, n),
			np.sqrt(sigma2eff_num(r, n, reff)),
			calc_mean(r, n),
			calc_sd(r, n),
		))
	elif type_ == b'gamma':
		label = 'gamma r$_\\mathrm{eff}$ = %.0f $\\mu$m, $\\sigma_\\mathrm{eff}$ = %.0f $\\mu$m' % (reff, sigmaeff)
		n = gamma_pdf(r, reff, sigmaeff)
		print('reff: %f sigmaeff: %f reff_num: %f sigmaeff_num: %f mean: %f sd: %f' % (
			reff,
			sigmaeff,
			reff_num(r, n),
			np.sqrt(sigma2eff_num(r, n, reff)),
			calc_mean(r, n),
			calc_sd(r, n),
		))
	else:
		raise ValueError('Invalid type: %s' % type_)

	plt.plot(r, n/np.nanmax(n), lw=1, color=col, label=label)
	# plt.axvline(reff, linestyle='dashed', color=col, lw=0.7)
	# plt.axvline(reff - sigmaeff, linestyle='dotted', color=col, lw=0.7)
	# plt.axvline(reff + sigmaeff, linestyle='dotted', color=col, lw=0.7)
	plt.xlabel('r ($\mu$m)')
	plt.ylabel('n(r)')
	#plt.title(title)

if __name__ == '__main__':
	stderr = os.fdopen(sys.stderr.fileno(), 'wb')
	args, opts = pst.decode_argv(sys.argv)

	if len(args) < 3:
		stderr.write(b'Usage: %s { <type> <reff> <sigmaeff> }... <output> num: <num>\n' % args[0])
		sys.exit(1)

	output = args[-1]
	num = opts.get(b'num', 100000)
	r = np.linspace(1e-3, 50., num)
	plt.figure(figsize=(6, 6))
	for i, arg in enumerate(args[1:-1]):
		type_ = arg[0]
		reff = arg[1]
		sigmaeff = arg[2]
		plot(type_, reff, sigmaeff, col=COL[i])
	legend = plt.legend(fontsize=9)
	plt.savefig(os.fsdecode(output), bbox_inches='tight')
